---
title: "Handle Extraction Errors"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
library(knitr)
```

## Overview

This notebook implements comprehensive error handling for the Fusarium extraction pipeline, applying concepts from notebook 0030.

## Load Packages and Data

```{r load-all}
library(dplyr)

source("../R/gemini_extraction.R")
source("../R/retry_logic.R")
source("../R/utils.R")

data_dir <- "../data/fusarium"
sample_10 <- readRDS(file.path(data_dir, "sample_10_studies.rds"))

tibble(
  Dataset = "Test sample",
  Studies = nrow(sample_10)
) %>% kable()
```

## Test Extraction with Retry

```{r extraction-with-retry}
test_study <- sample_10[1, ]

result <- retry_with_backoff({
  extract_fusarium_gemini(
    abstract = test_study$abstract_clean,
    title = test_study$title,
    keywords = safe_text(test_study$keywords_clean)
  )
}, max_attempts = 3, base_delay = 2)

tibble(
  Field = c("ID", "Species extracted", "Crops extracted"),
  Value = c(
    test_study$id,
    length(result$fusarium_species),
    length(result$crop)
  )
) %>% kable()
```

## Safe Extraction Wrapper

Create production-ready extraction wrapper with all error handling.

```{r safe-extraction-wrapper}
extract_fusarium_safe <- function(study, max_attempts = 3) {
  result <- tryCatch({
    retry_with_backoff({
      extract_fusarium_gemini(
        abstract = study$abstract_clean,
        title = study$title,
        keywords = safe_text(study$keywords_clean)
      )
    }, max_attempts = max_attempts, base_delay = 2)
  }, error = function(e) {
    list(
      error = TRUE,
      error_message = conditionMessage(e),
      id = study$id
    )
  })

  if (is.null(result$error)) {
    result$id <- study$id
    result$error <- FALSE
  }

  result
}
```

## Test Safe Wrapper

```{r test-safe-wrapper}
test_results <- tibble(
  Study = integer(),
  Status = character(),
  Error = character()
)

for (i in 1:min(5, nrow(sample_10))) {
  result <- extract_fusarium_safe(sample_10[i, ])

  test_results <- bind_rows(test_results, tibble(
    Study = i,
    Status = ifelse(result$error, "Failed", "Success"),
    Error = ifelse(result$error, result$error_message, "")
  ))

  Sys.sleep(2)
}

test_results %>% kable()
```

## Error Handling Summary

```{r error-summary}
tibble(
  Metric = c("Studies processed", "Successful", "Failed", "Success rate"),
  Value = c(
    nrow(test_results),
    sum(test_results$Status == "Success"),
    sum(test_results$Status == "Failed"),
    paste0(round(mean(test_results$Status == "Success") * 100), "%")
  )
) %>% kable()
```

## Error Handling Features

```{r features}
tibble(
  Feature = c(
    "Exponential backoff retry",
    "Graceful error catching",
    "Error message logging",
    "Continues on failure",
    "Rate limiting built-in"
  ),
  Description = c(
    "Retries failed requests with increasing delays",
    "Catches errors without stopping execution",
    "Records error messages for debugging",
    "Processes remaining studies after failure",
    "Adds delay between API calls"
  )
) %>% kable()
```

## Next Steps

Proceed to `0400_batch_processing.Rmd` for batch processing implementation.
