---
title: "Setup Project Environment"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = TRUE, warning = TRUE)
library(knitr)
```

## Project Setup

This notebook verifies the R environment and installs all required packages for the LLM text extraction project.

## Check R Version

```{r check-r-version}
tibble::tibble(
  Property = c("R Version", "Platform", "Working Directory"),
  Value = c(R.version.string, R.version$platform, getwd())
) %>% kable()
```

## Required Packages

```{r package-list}
required_packages <- c(
  "ellmer",
  "httr",
  "xml2",
  "dplyr",
  "tidyr",
  "stringr",
  "ggplot2",
  "jsonlite",
  "readr",
  "purrr",
  "tidytext",
  "topicmodels",
  "wordcloud"
)

tibble::tibble(Package = required_packages) %>% kable()
```

## Check Installed Packages

```{r check-packages}
installed <- sapply(required_packages, function(pkg) {

  requireNamespace(pkg, quietly = TRUE)
})

tibble::tibble(
  Package = required_packages,
  Status = ifelse(installed, "Installed", "Missing")
) %>% kable()

missing_packages <- required_packages[!installed]
```

## Install Missing Packages

```{r install-packages}
if (length(missing_packages) > 0) {
  for (pkg in missing_packages) {
    install.packages(pkg, repos = "https://cloud.r-project.org", quiet = TRUE)
  }
}

tibble::tibble(
  Metric = c("Missing packages", "Action"),
  Value = c(
    length(missing_packages),
    ifelse(length(missing_packages) > 0, "Installed", "None needed")
  )
) %>% kable()
```

## Verify Package Loading

```{r load-packages}
load_success <- sapply(required_packages, function(pkg) {
  tryCatch({
    library(pkg, character.only = TRUE)
    TRUE
  }, error = function(e) FALSE)
})

tibble::tibble(
  Package = required_packages,
  Loaded = ifelse(load_success, "Yes", "No")
) %>% kable()
```

## Check API Key Configuration

```{r check-api-key}
if (file.exists(".env")) {
  readRenviron(".env")
}

google_key <- Sys.getenv("GOOGLE_API_KEY")
pubmed_key <- Sys.getenv("PUB_MED_API_KEY")
scopus_key <- Sys.getenv("SCOPUS_API_KEY")

tibble::tibble(
  `API Key` = c("GOOGLE_API_KEY", "PUB_MED_API_KEY", "SCOPUS_API_KEY"),
  Status = c(
    ifelse(nchar(google_key) > 0, "Configured", "Not set"),
    ifelse(nchar(pubmed_key) > 0, "Configured", "Not set (optional)"),
    ifelse(nchar(scopus_key) > 0, "Configured", "Not set")
  )
) %>% kable()
```

## Check Project Directory Structure

```{r check-directories}
required_dirs <- c(
  "data", "data/cache", "data/logs", "data/fusarium",
  "R", "notebooks", "results", "dev"
)

dir_status <- sapply(required_dirs, function(dir_path) {
  exists <- dir.exists(dir_path)
  if (!exists) {
    dir.create(dir_path, showWarnings = FALSE, recursive = TRUE)
  }
  dir.exists(dir_path)
})

tibble::tibble(
  Directory = required_dirs,
  Status = ifelse(dir_status, "Ready", "Created")
) %>% kable()
```

## Source Project Functions

```{r source-functions}
r_files <- c(
  "R/utils.R", "R/pubmed_api.R", "R/scopus_api.R", "R/retry_logic.R",
  "R/batch_processor.R", "R/cache_manager.R", "R/gemini_extraction.R",
  "R/extractors.R", "R/evaluation.R"
)

source_status <- sapply(r_files, function(r_file) {
  if (file.exists(r_file)) {
    source(r_file)
    "Loaded"
  } else {
    "Missing"
  }
})

tibble::tibble(
  File = r_files,
  Status = source_status
) %>% kable()
```

## Environment Summary

```{r summary}
google_set <- nchar(google_key) > 0
pubmed_set <- nchar(pubmed_key) > 0
scopus_set <- nchar(scopus_key) > 0

tibble::tibble(
  Component = c(
    "R Version", "Packages", "Google API",
    "PubMed API", "Scopus API", "Directories", "Functions"
  ),
  Status = c(
    R.version.string,
    ifelse(all(load_success), "All loaded", "Some failed"),
    ifelse(google_set, "Configured", "Not set"),
    ifelse(pubmed_set, "Configured", "Optional"),
    ifelse(scopus_set, "Configured", "Not set"),
    "Ready",
    "Loaded"
  )
) %>% kable()
```

## Next Steps

1. If API key is not set, obtain one from Google AI Studio
2. Create `.env` file with your API key
3. Proceed to `0010_test_gemini_api.Rmd` to test API connectivity
