---
title: "Error Handling and Retry Logic"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
library(knitr)
```

## Error Handling for API Calls

This notebook introduces error handling techniques for robust LLM extraction.

## Load Packages and Functions

```{r load-packages}
library(dplyr)
library(jsonlite)

source("../R/gemini_extraction.R")
source("../R/retry_logic.R")
```

## Common API Errors

```{r error-types}
tibble(
  Error = c(
    "HTTP 429", "HTTP 500", "HTTP 401/403",
    "Network Timeout", "JSON Parse Error"
  ),
  Description = c(
    "Rate limit exceeded",
    "Internal server error",
    "Authentication error",
    "Slow connection",
    "Malformed response"
  ),
  Solution = c(
    "Wait and retry with backoff",
    "Retry after short delay",
    "Check API key configuration",
    "Retry with longer timeout",
    "Validate response, retry if needed"
  )
) %>% kable(caption = "Common API errors and solutions")
```

## Exponential Backoff

```{r backoff-concept}
base_delay <- 1
max_attempts <- 5

backoff_schedule <- tibble(
  Attempt = 1:max_attempts,
  `Wait (seconds)` = base_delay * (2 ^ (0:(max_attempts-1)))
)

backoff_schedule %>% kable(caption = "Exponential backoff schedule")

tibble(
  Metric = c("Base delay", "Max attempts", "Total wait time"),
  Value = c(
    paste(base_delay, "second"),
    max_attempts,
    paste(sum(backoff_schedule$`Wait (seconds)`), "seconds")
  )
) %>% kable()
```

## Test 1: Basic Retry Logic

```{r test-basic-retry}
attempt_count <- 0

flaky_function <- function() {
  attempt_count <<- attempt_count + 1
  if (attempt_count < 3) {
    stop("Simulated error - attempt ", attempt_count)
  }
  return("Success!")
}

attempt_count <- 0

result <- retry_with_backoff({
  flaky_function()
}, max_attempts = 5, base_delay = 0.5)

tibble(
  Metric = c("Final result", "Total attempts"),
  Value = c(result, attempt_count)
) %>% kable(caption = "Retry test results")
```

## Test 2: Rate Limit Simulation

```{r test-rate-limit}
call_times <- numeric()

rate_limited_api <- function() {
  current_time <- as.numeric(Sys.time())
  call_times <<- c(call_times, current_time)
  recent_calls <- sum(call_times > (current_time - 5))

  if (recent_calls > 2) {
    stop("HTTP 429: Rate limit exceeded")
  }
  return(list(status = "success", data = "API response"))
}

call_times <- numeric()
results <- list()

for (i in 1:5) {
  results[[i]] <- retry_with_backoff({
    rate_limited_api()
  }, max_attempts = 3, base_delay = 1)
}

tibble(
  Call = 1:5,
  Status = sapply(results, function(r) r$status)
) %>% kable(caption = "Rate limit test results")
```

## Test 3: Safe Extraction Wrapper

```{r test-safe-extract}
test_texts <- c(
  "Normal text to extract from",
  "",
  "Another normal text",
  NA,
  "Final text"
)

dummy_extract <- function(text) {
  if (is.na(text) || nchar(text) == 0) {
    stop("Cannot extract from empty text")
  }
  return(list(text = text, length = nchar(text)))
}

results <- list()
for (i in seq_along(test_texts)) {
  result <- safe_extract(
    extract_fn = dummy_extract,
    doc_id = i,
    text = test_texts[i],
    verbose = FALSE
  )
  if (!is.null(result)) {
    results[[length(results) + 1]] <- result
  }
}

tibble(
  Metric = c("Total texts", "Successful", "Failed"),
  Count = c(length(test_texts), length(results), length(test_texts) - length(results))
) %>% kable(caption = "Safe extraction results")
```

## Test 4: Real API with Retry

```{r test-real-api}
extract_with_retry <- function(text) {
  retry_with_backoff({
    prompt <- sprintf('Extract the main topic in 3 words: "%s"', text)
    simple_gemini(prompt)
  }, max_attempts = 3, base_delay = 2)
}

test_texts <- c(
  "Climate change affects global agriculture",
  "Machine learning improves medical diagnosis",
  "Renewable energy reduces carbon emissions"
)

api_results <- list()
for (i in seq_along(test_texts)) {
  api_results[[i]] <- tryCatch({
    extract_with_retry(test_texts[i])
  }, error = function(e) "Failed")
  Sys.sleep(1)
}

tibble(
  Text = substr(test_texts, 1, 40),
  Extracted = unlist(api_results)
) %>% kable(caption = "Real API extraction results")
```

## Resilient Extraction Function

```{r resilient-extraction}
resilient_extract <- function(texts, extract_fn, max_attempts = 3, delay = 2) {
  results <- list()
  errors <- list()

  for (i in seq_along(texts)) {
    result <- tryCatch({
      retry_with_backoff({
        extract_fn(texts[i])
      }, max_attempts = max_attempts, base_delay = 1)
    }, error = function(e) {
      errors[[i]] <<- conditionMessage(e)
      NULL
    })

    if (!is.null(result)) {
      results[[i]] <- result
    }

    if (i < length(texts)) Sys.sleep(delay)
  }

  list(
    results = results,
    errors = errors,
    success_rate = length(results) / length(texts)
  )
}
```

## Test Resilient Extraction

```{r test-resilient}
abstracts <- c(
  "Fusarium graminearum infection in wheat under drought conditions.",
  "Temperature effects on mycotoxin production in barley.",
  "Climate models predict increased Fusarium head blight severity."
)

extract_keywords <- function(text) {
  prompt <- sprintf('Extract 3 key terms from: "%s". Return comma-separated.', text)
  simple_gemini(prompt)
}

extraction_results <- resilient_extract(
  texts = abstracts,
  extract_fn = extract_keywords,
  max_attempts = 3,
  delay = 2
)

tibble(
  Metric = c("Total texts", "Successful", "Success rate"),
  Value = c(
    length(abstracts),
    length(extraction_results$results),
    paste0(round(extraction_results$success_rate * 100, 1), "%")
  )
) %>% kable(caption = "Resilient extraction summary")
```

## Best Practices

```{r best-practices}
tibble(
  Practice = c(
    "Always use retry logic",
    "Respect rate limits",
    "Log all errors",
    "Fail gracefully",
    "Monitor performance"
  ),
  Implementation = c(
    "Exponential backoff, 3-5 attempts",
    "Add delays between requests, batch processing",
    "Save error messages, track failures",
    "Continue on single errors, collect partial results",
    "Track success rate, measure latency"
  )
) %>% kable(caption = "Error handling best practices")
```

## Rate Limit Guidelines

```{r rate-limit-guide}
tibble(
  `Processing Rate` = c("Conservative", "Moderate", "Aggressive"),
  `Docs/min` = c(10, 20, 40),
  `Delay (sec)` = c(6, 3, 1.5),
  `2,663 docs time` = c("~4.4 hours", "~2.2 hours", "~1.1 hours")
) %>% kable(caption = "Rate limit guidelines")
```

## Summary

```{r summary}
tibble(
  Concept = c(
    "Exponential Backoff",
    "Retry Logic",
    "Safe Extraction",
    "Rate Limiting",
    "Graceful Degradation"
  ),
  Description = c(
    "Wait longer between retries",
    "Automatically recover from failures",
    "Continue despite errors",
    "Respect API constraints",
    "Collect partial results"
  )
) %>% kable(caption = "Key error handling concepts")
```

## Next Steps

1. Understand API errors and solutions
2. Implement retry logic with exponential backoff
3. Build resilient extraction functions
4. Load real Fusarium data in `0100_load_fusarium_data.Rmd`
