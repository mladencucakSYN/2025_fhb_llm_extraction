---
title: "Project Structure and Function Loading"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = TRUE, warning = TRUE)
library(knitr)
```

## Understanding Project Organization

This notebook explains the project structure and how to work with reusable functions.

## Project Directory Structure

```{r show-structure}
tibble::tibble(
  Directory = c("R/", "notebooks/", "dev/", "data/", "results/", "tests/"),
  Purpose = c(
    "Production functions (reusable, tested, documented)",
    "R Markdown analysis notebooks",
    "Development and testing (not tracked in git)",
    "Data files, cache, logs",
    "Output files and reports",
    "Unit tests (testthat)"
  )
) %>% kable()
```

## R/ vs dev/ Directory Distinction

```{r explain-separation}
tibble::tibble(
  Aspect = c("Purpose", "Quality", "Used by", "Git tracked", "Examples"),
  `R/ Directory` = c(
    "Stable, tested, reusable functions",
    "Documented, error-handled, reliable",
    "All notebooks, other researchers",
    "Yes",
    "retry_with_backoff(), extract_fusarium_gemini()"
  ),
  `dev/ Directory` = c(
    "Experimental code, quick tests",
    "May be incomplete, untested",
    "Only during development",
    "No (except .md files)",
    "test_new_prompt.R, debug_rate_limits.R"
  )
) %>% kable()
```

## Development Workflow

```{r workflow}
tibble::tibble(
  Stage = 1:5,
  Phase = c(
    "Experimentation", "Notebook Integration",
    "Refinement", "Promotion to R/", "Maintenance"
  ),
  Description = c(
    "Write experimental code in dev/",
    "Test in notebooks with multiple examples",
    "Handle edge cases, add error checking",
    "Move to R/ when used 3+ times",
    "Update documentation, add tests"
  )
) %>% kable()
```

## Loading Functions

```{r load-functions-demo}
tibble::tibble(
  Method = c("Individual files", "All R functions", "Selective (recommended)"),
  Code = c(
    'source("../R/utils.R")',
    'lapply(list.files("../R", "\\\\.R$", full.names=TRUE), source)',
    'source("../R/utils.R"); source("../R/gemini_extraction.R")'
  ),
  `Use Case` = c(
    "Single specific module",
    "Need all project functions",
    "Load only what notebook needs"
  )
) %>% kable()

# Load project functions
source("../R/utils.R")
source("../R/gemini_extraction.R")
source("../R/retry_logic.R")
```

## Available Functions

```{r inspect-functions}
tibble::tibble(
  Source = c(rep("utils.R", 3), rep("gemini_extraction.R", 4), rep("retry_logic.R", 3)),
  Function = c(
    "load_config()", "clean_text()", "save_results()",
    "simple_gemini()", "extract_fusarium_gemini()",
    "extract_generic_gemini()", "extract_fusarium_with_retry()",
    "retry_with_backoff()", "retry_api_call()", "safe_extract()"
  ),
  Description = c(
    "Load API keys from .env",
    "Clean and normalize text",
    "Save extraction results",
    "Basic Gemini chat",
    "Fusarium-specific extraction",
    "Generic extraction",
    "Extraction with retry logic",
    "Exponential backoff retry",
    "API-specific retry wrapper",
    "Error-handling wrapper"
  )
) %>% kable()
```

## Function Usage Examples

```{r use-functions}
# Example 1: Load configuration
config <- load_config()

tibble::tibble(
  `API Key` = c("OpenAI", "Anthropic"),
  Configured = c(
    nchar(config$openai_api_key) > 0,
    nchar(config$anthropic_api_key) > 0
  )
) %>% kable()

# Example 2: Clean text
messy_text <- "  This  has\n\nmultiple\t\tspaces  "
clean <- clean_text(messy_text)

tibble::tibble(
  Stage = c("Before", "After"),
  Text = c(messy_text, clean)
) %>% kable()
```

## Documentation Standards

```{r documentation-standards}
tibble::tibble(
  Element = c(
    "roxygen2 header", "Clear parameter names",
    "Input validation", "Error handling", "Examples"
  ),
  Description = c(
    "#' @param, #' @return, #' @export annotations",
    "Descriptive, self-documenting names",
    "Check types and ranges",
    "tryCatch with informative messages",
    "Working examples in comments"
  )
) %>% kable()
```

## Function Availability Check

```{r check-availability}
expected_functions <- c(
  "load_config", "clean_text", "simple_gemini",
  "extract_fusarium_gemini", "retry_with_backoff", "safe_extract"
)

tibble::tibble(
  Function = expected_functions,
  Available = sapply(expected_functions, exists, mode = "function")
) %>% kable()
```

## Best Practices

```{r best-practices}
tibble::tibble(
  Category = c(rep("Do", 5), rep("Don't", 5)),
  Practice = c(
    "Load at beginning of notebook",
    "Use relative paths: '../R/filename.R'",
    "Source only what you need",
    "Check if functions exist",
    "Handle source errors with tryCatch",
    "Source in middle of analysis",
    "Use absolute paths",
    "Source same file multiple times",
    "Mix function definitions with sourcing",
    "Leave untested code in R/"
  )
) %>% kable()
```

## Summary

```{r summary}
tibble::tibble(
  Topic = c(
    "Directory structure",
    "Development workflow",
    "Loading functions",
    "Documentation"
  ),
  `Key Point` = c(
    "R/ for production, dev/ for experiments",
    "Experiment -> Test -> Refine -> Promote -> Maintain",
    "source('../R/filename.R') at notebook start",
    "roxygen2 headers, clear params, error handling"
  )
) %>% kable()
```

## Next Steps

1. Understand project structure
2. Know how to load functions
3. Understand development workflow
4. Continue with API testing in `0010_test_gemini_api.Rmd`
